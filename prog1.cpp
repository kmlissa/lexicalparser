//Lexical Analyzer and Recursive-Descent program.
//By: Katimu Lissa and Oliver Yellock.


#include <iostream>
#include <ctype.h>

#include <fstream>
using namespace std;

//declare variables
int lexLength;
int token;
int charClass;
char lexeme[100];
char nextChar;
int nextToken;
FILE *file1, *fopen();

//declare functions
int declare();
int declarident();
int stmts();
int assign();
int expr();
int funcname();
void addChar();
void getChar();
void notBlank();
int keyword();
void ident();
int lex();
void error(string lexeme);
bool program();
void callSwitch();

//character classes
#define LETTER 0
#define UNKNOWN 99

//tokens 
#define IDENT 11
#define ASSIGN_OP 20
#define MULT_OP 21
#define DIV_OP 22
#define LEFT_PAREN 23
#define RIGHT_PAREN 24
#define LEFT_BRACE 25
#define RIGHT_BRACE 26
#define COMMA 27
#define SEMI_COLON 28
#define ADD_OP 29
#define SUB_OP 30
#define KEYWORD 31


//main class
int main() {
    //Calls the switch that activates the lexical analyzer and recursive descent parser.
    callSwitch();
	return 0;
}


//*********Lexical Analyzer*********//

//gets operators and paren and returns token
int find(char mychar) {
	
    switch (mychar) {
        case '(': // Left Paren
            addChar();
            nextToken = LEFT_PAREN;
            break;
            
        case ')': // Right Paren
            addChar();
            nextToken = RIGHT_PAREN;
            break;
            
        case '*': // Multiplication
            addChar();
            nextToken = MULT_OP;
            break;
            
        case '/': // Division
            addChar();
            nextToken = DIV_OP;
            break;
            
		case '+': //Add operator
			addChar();
			nextToken = ADD_OP;
			break;
			
		case '-': //Subtract operator
			addChar();
			nextToken = SUB_OP;
			break;
		
	
        default: // EOF
            addChar();
            nextToken = EOF;
            break;
    }
	
    return nextToken;
}


//function to add nextChar to lexeme
void addChar() {
    
    if (lexLength <= 98) {
        lexeme[lexLength++] = nextChar;
        lexeme[lexLength] = 0;
    }
    else
        cout<<("Error occurred, lexeme is too long \n")<<endl;
}

//function gets next character input and determine its character class
void getChar() {
    if ((nextChar = getc(file1)) != EOF) {
        if (isalpha(nextChar))
			charClass = LETTER;
        else charClass = UNKNOWN;
    }else
        charClass = EOF;
}


//function to call getChar until it returns a non whitespace character
void notBlank() {
    while (isspace(nextChar))
        getChar();
}

//check if the next characters combine to be one of these few keywords.


//lexical analyzer for math operations
int lex() {
    lexLength = 0;
    notBlank();
    switch (charClass) {
		
        // Parse identifiers and keywords.
		case LETTER:
            addChar();
            getChar();
            while (charClass == LETTER) {
                addChar();
                getChar();
            }
			
        nextToken = IDENT;
            break;
            
           //Parentheses and operators
        case UNKNOWN:
            find(nextChar);
            getChar();
            break;
			
            //EOF
        case EOF:
            nextToken = EOF;
            lexeme[0] = 'E';
            lexeme[1] = 'O';
            lexeme[2] = 'F';
            lexeme[3] = 0;
            break;
            
    } //End of switch stmt
    printf("Next token: %d, Next lexeme is %s\n",
           nextToken, lexeme);
    return nextToken;
}



//*********Recursive-Descent Parser*********//

/*program
	Parses strings in the language generated by the rule:
	<keyword><funcname>(){<declare><stmts>}
		*/	

 bool program(){
	//Parse keyword.
	if(keyword() == -1) return false;
	
	//Parse function.
	if(funcname() == -1) return false;
	
	//As long as the next token is '(' , get the next token, else display only the error.
	if(nextToken == LEFT_PAREN) lex();
	else {
		error("(");
		return false;
	}
	
	//As long as the next token is ')' , get the next token, else display only the error.
	if(nextToken == RIGHT_PAREN) lex();
	else {
		error(")");
		return false;
	}
	
	//As long as the next token is '{' , get the next token, else display only the error.
	if(nextToken == LEFT_BRACE) lex();
	else{
		error("{");
		return false;
	}
	
	//Parse declare.
	if(declare() == -1) return false;
	
	//Parse statements.
	if(stmts() == -1) return false;
	
	//As long as the next token is '}', return success, else display only the error.
	if(nextToken != RIGHT_BRACE){
		error("}");
		return false;
	}
	
	return true;
}

//Check if keyword.
int keyword(){
	if(nextToken == KEYWORD){
		lex();
	} else {
		error("a keyword for the return type");
		return -1;
	}
}

//Parses in the form <keyword><ident>; | <keyword><ident>,<declarident>
int declare(){
	if(nextToken == KEYWORD) 
		lex();
	else {
		error("a keyword for an identifier");
		return -1;
	}
	
	if(nextToken == IDENT){
			ident();
	}else {
		error("an identifier");
		return -1;
	}
	
	if(nextToken == SEMI_COLON) lex();
	else if(nextToken == COMMA){
		lex();
		declarident();
	}
	else{
		error("a semi colon or comma when declaring.");
		return -1;
	}
	
}

//Parses in the form <ident>,<declarident> | <ident>;
int declarident(){
	if(nextToken == IDENT){
		ident();
	}else{
		error("an identifier for the declarident.");
		return -1;
	}
	
	if(nextToken == COMMA){
		lex();
		declarident();
	}
	else if(nextToken == SEMI_COLON) lex();
	else{
		error("a comma or semicolon in the declarident.");
		return -1;
	}
}

//Parses in the form <assign>;<stmts> | <assign>;
int stmts(){
	if(nextToken == IDENT){
		
		if(assign() == -1) return -1;
		
	} else{
		error("in assignment form");
		return -1;
	}
	
	if(nextToken == SEMI_COLON){
		lex();
		if(nextToken == IDENT){
		if(stmts() == -1) return -1;
		lex();
		}
	}
	else{
		error("a semi colon or semi colon and then statement");
		return -1;
	}
}

//Parses in the form <ident> = <expr>
int assign(){
	if(nextToken == IDENT){
		ident();
		
		
	}else{
		error("an identifier when assigning.");
		return -1;
	}
	
	if(nextToken == ASSIGN_OP) {
		if(expr() == -1) return -1;
	}else{
		//string dd = to_string(nextToken);
		error("an assignment operator.");
		return -1;
	}
}

//Parses in the form <ident> {+|-} <expr> | <ident>
int expr(){
	lex();
	if(nextToken == IDENT){
		ident();
	}else{
		error("an identifier in the expression.");
		return -1;
	}

	while(nextToken == ADD_OP || nextToken == SUB_OP){
			//lex();
			if(expr() == -1) return -1;
			
	}
	
	if((nextToken != ADD_OP || nextToken != SUB_OP) && nextToken != SEMI_COLON ){
		error("an addition or subtraction operator");
		return -1;
	}
	
}

//Parses in the form <ident>
int funcname(){
	if(nextToken == IDENT) lex();
	else{
		error("an identifier for a function name.");
		return -1;
	}
}

//Parses in the form a<ident>|b<ident>|...|z<ident>|empty
void ident(){
	if(lex() == LETTER) lex();
}

//Displays the output of a compiler error and which lexeme caused it.
void error(string token){
	cout << "Compiler Error!! The token is not '" + token + "'";
}

//Calls for user input of a file, displays lexical analyzer for file and using recursive descent parser displays if the file is in correct form.
void callSwitch() {
	//open file
	if((file1 = fopen("comb.txt", "r")) == NULL){
		printf("file not....");
	}else{
		getChar();
		 do{
			 lex();
		 }while(nextToken!=EOF);
	}

	}	






















